# DeliteAI Mobile Cursor Rules (sdks/android/, sdks/ios/)

These rules apply specifically to mobile development for DeliteAI Android and iOS SDKs.

## Mobile Development Principles

### Cross-Platform Consistency
- Maintain API parity between Android and iOS SDKs
- Use consistent naming conventions across platforms
- Ensure identical functionality and behavior
- Test on both platforms for any changes

### Performance Optimization
- Optimize for mobile device constraints (CPU, memory, battery)
- Use efficient algorithms suitable for mobile hardware
- Minimize memory allocations in critical paths
- Profile memory usage and performance regularly
- Consider offline-first architecture patterns

### Security & Privacy
- Follow platform-specific security guidelines
- Implement proper data encryption for sensitive data
- Handle permissions appropriately for each platform
- Ensure all AI processing remains on-device
- Follow privacy-by-design principles

## Android Development (sdks/android/)

### Code Standards
- Follow Android Kotlin style guide
- Use Kotlin as the primary language
- Implement proper lifecycle management
- Follow Material Design guidelines for UI components
- Use Jetpack Compose for modern UI when appropriate

### Architecture Patterns
- Use MVVM or MVP architecture patterns
- Implement proper dependency injection (Hilt/Dagger)
- Use Room for local database operations
- Implement proper background processing with WorkManager
- Use Kotlin coroutines for asynchronous operations

### Gradle Configuration
```kotlin
// build.gradle.kts example for DeliteAI Android SDK
android {
    compileSdk = 34
    
    defaultConfig {
        minSdk = 24
        targetSdk = 34
        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
    }
    
    buildTypes {
        release {
            isMinifyEnabled = true
            proguardFiles(getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro")
        }
    }
    
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
    }
    
    kotlinOptions {
        jvmTarget = "1.8"
    }
}

dependencies {
    implementation("androidx.lifecycle:lifecycle-runtime-ktx:2.7.0")
    implementation("androidx.work:work-runtime-ktx:2.9.0")
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3")
    
    testImplementation("junit:junit:4.13.2")
    testImplementation("org.mockito:mockito-core:5.1.1")
    androidTestImplementation("androidx.test.ext:junit:1.1.5")
}
```

### API Design Patterns
```kotlin
package ai.delite.sdk

import kotlinx.coroutines.*
import android.content.Context

class DeliteAIClient(private val context: Context) {
    private val scope = CoroutineScope(Dispatchers.Main + SupervisorJob())
    
    suspend fun initialize(config: DeliteAIConfig): Result<Unit> = withContext(Dispatchers.IO) {
        try {
            // Initialize native components
            val success = nativeInitialize(config.toNativeConfig())
            if (success) {
                Result.success(Unit)
            } else {
                Result.failure(DeliteAIException("Failed to initialize native components"))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    suspend fun processData(inputData: Map<String, Any>): Result<Map<String, Any>> {
        return withContext(Dispatchers.Default) {
            try {
                val result = nativeProcessData(inputData)
                Result.success(result)
            } catch (e: Exception) {
                Result.failure(DeliteAIException("Data processing failed", e))
            }
        }
    }
    
    private external fun nativeInitialize(config: Long): Boolean
    private external fun nativeProcessData(data: Map<String, Any>): Map<String, Any>
    
    companion object {
        init {
            System.loadLibrary("deliteai_native")
        }
    }
}

data class DeliteAIConfig(
    val modelPath: String,
    val maxTokens: Int = 100,
    val temperature: Float = 0.7f
) {
    fun toNativeConfig(): Long {
        // Convert to native configuration pointer
        return createNativeConfig(modelPath, maxTokens, temperature)
    }
    
    private external fun createNativeConfig(path: String, tokens: Int, temp: Float): Long
}

class DeliteAIException(message: String, cause: Throwable? = null) : Exception(message, cause)
```

### Testing Patterns
```kotlin
@RunWith(AndroidJUnit4::class)
class DeliteAIClientTest {
    
    @get:Rule
    val instantTaskExecutorRule = InstantTaskExecutorRule()
    
    private lateinit var context: Context
    private lateinit var client: DeliteAIClient
    
    @Before
    fun setup() {
        context = InstrumentationRegistry.getInstrumentation().targetContext
        client = DeliteAIClient(context)
    }
    
    @Test
    fun testInitialization() = runTest {
        val config = DeliteAIConfig(
            modelPath = "test/model/path",
            maxTokens = 50
        )
        
        val result = client.initialize(config)
        
        assertTrue(result.isSuccess)
    }
    
    @Test
    fun testDataProcessing() = runTest {
        // Setup
        val inputData = mapOf("text" to "Hello, world!")
        
        // Execute
        val result = client.processData(inputData)
        
        // Verify
        assertTrue(result.isSuccess)
        assertNotNull(result.getOrNull())
    }
}
```

## iOS Development (sdks/ios/)

### Code Standards
- Follow Apple Swift style guidelines
- Use Swift 5.0+ with modern language features
- Implement proper memory management with ARC
- Follow iOS Human Interface Guidelines
- Use SwiftUI for modern UI when appropriate

### Architecture Patterns
- Use MVVM or VIPER architecture patterns
- Implement proper dependency injection
- Use Core Data or SQLite for local storage
- Use GCD or async/await for asynchronous operations
- Follow iOS app lifecycle patterns

### Podspec Configuration
```ruby
# DeliteAI.podspec
Pod::Spec.new do |spec|
  spec.name                  = 'DeliteAI'
  spec.version               = '0.1.0'
  spec.summary               = 'DeliteAI iOS SDK for on-device AI processing'
  spec.description           = 'Privacy-first on-device AI platform for iOS applications'
  
  spec.homepage              = 'https://deliteai.dev'
  spec.license               = { :type => 'Apache-2.0', :file => 'LICENSE' }
  spec.author                = { 'DeliteAI Team' => 'team@deliteai.dev' }
  spec.source                = { :git => 'https://github.com/NimbleEdge/deliteAI.git', :tag => spec.version.to_s }
  
  spec.ios.deployment_target = '13.0'
  spec.swift_version         = '5.0'
  
  spec.source_files          = 'deliteAI/Classes/**/*'
  spec.public_header_files   = 'deliteAI/Classes/**/*.h'
  
  spec.vendored_frameworks   = []  # Add when available
  
  spec.pod_target_xcconfig   = {
    'OTHER_CFLAGS'           => '-O2',
    'ENABLE_BITCODE'         => 'NO',
    'SWIFT_OPTIMIZATION_LEVEL' => '-O'
  }
  
  spec.user_target_xcconfig  = {
    'ENABLE_BITCODE'         => 'NO'
  }
end
```

### API Design Patterns
```swift
import Foundation

@objc public class DeliteAIClient: NSObject {
    private let queue = DispatchQueue(label: "ai.delite.sdk.processing", qos: .userInitiated)
    private var isInitialized = false
    
    @objc public override init() {
        super.init()
    }
    
    @objc public func initialize(config: DeliteAIConfig) async throws {
        return try await withCheckedThrowingContinuation { continuation in
            queue.async {
                do {
                    let success = self.nativeInitialize(config.toNativeConfig())
                    if success {
                        self.isInitialized = true
                        continuation.resume()
                    } else {
                        continuation.resume(throwing: DeliteAIError.initializationFailed)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }
    
    @objc public func processData(_ inputData: [String: Any]) async throws -> [String: Any] {
        guard isInitialized else {
            throw DeliteAIError.notInitialized
        }
        
        return try await withCheckedThrowingContinuation { continuation in
            queue.async {
                do {
                    let result = self.nativeProcessData(inputData)
                    continuation.resume(returning: result)
                } catch {
                    continuation.resume(throwing: DeliteAIError.processingFailed(error))
                }
            }
        }
    }
    
    private func nativeInitialize(_ config: UnsafeMutableRawPointer) -> Bool {
        // Call C++ implementation
        return nimblenet_initialize(config)
    }
    
    private func nativeProcessData(_ data: [String: Any]) -> [String: Any] {
        // Call C++ implementation
        return nimblenet_process_data(data)
    }
}

@objc public class DeliteAIConfig: NSObject {
    @objc public let modelPath: String
    @objc public let maxTokens: Int
    @objc public let temperature: Float
    
    @objc public init(modelPath: String, maxTokens: Int = 100, temperature: Float = 0.7) {
        self.modelPath = modelPath
        self.maxTokens = maxTokens
        self.temperature = temperature
        super.init()
    }
    
    func toNativeConfig() -> UnsafeMutableRawPointer {
        // Convert to C++ configuration
        return create_native_config(modelPath, Int32(maxTokens), temperature)
    }
}

@objc public enum DeliteAIError: Int, Error, LocalizedError {
    case notInitialized
    case initializationFailed
    case processingFailed
    case invalidConfiguration
    
    public var errorDescription: String? {
        switch self {
        case .notInitialized:
            return "DeliteAI client not initialized"
        case .initializationFailed:
            return "Failed to initialize DeliteAI client"
        case .processingFailed:
            return "Data processing failed"
        case .invalidConfiguration:
            return "Invalid configuration provided"
        }
    }
}

extension DeliteAIError {
    static func processingFailed(_ underlyingError: Error) -> DeliteAIError {
        // Log underlying error for debugging
        print("Processing failed with error: \(underlyingError)")
        return .processingFailed
    }
}
```

### Testing Patterns
```swift
import XCTest
@testable import DeliteAI

class DeliteAIClientTests: XCTestCase {
    
    var client: DeliteAIClient!
    
    override func setUp() {
        super.setUp()
        client = DeliteAIClient()
    }
    
    override func tearDown() {
        client = nil
        super.tearDown()
    }
    
    func testInitialization() async throws {
        let config = DeliteAIConfig(
            modelPath: "test/model/path",
            maxTokens: 50
        )
        
        try await client.initialize(config: config)
        
        // Test should complete without throwing
    }
    
    func testDataProcessing() async throws {
        // Setup
        let config = DeliteAIConfig(modelPath: "test/model/path")
        try await client.initialize(config: config)
        
        let inputData: [String: Any] = ["text": "Hello, world!"]
        
        // Execute
        let result = try await client.processData(inputData)
        
        // Verify
        XCTAssertNotNil(result)
        XCTAssertFalse(result.isEmpty)
    }
    
    func testUninitializedProcessing() async {
        let inputData: [String: Any] = ["text": "Hello, world!"]
        
        do {
            _ = try await client.processData(inputData)
            XCTFail("Expected error for uninitialized client")
        } catch DeliteAIError.notInitialized {
            // Expected error
        } catch {
            XCTFail("Unexpected error: \(error)")
        }
    }
}
```

## Cross-Platform Integration

### C++ Bridge Patterns
- Use consistent function signatures across platforms
- Implement proper error handling in bridge code
- Use appropriate data conversion between native and platform types
- Include comprehensive logging for debugging

### Build System Integration
- Coordinate CMake builds with platform build systems
- Ensure consistent compiler flags across platforms
- Handle platform-specific dependencies properly
- Test build processes on continuous integration

### Version Management
- Synchronize version numbers across platforms
- Use semantic versioning consistently
- Coordinate releases between Android and iOS
- Update changelogs with platform-specific notes

## Common Mobile Patterns

### Background Processing
```kotlin
// Android WorkManager example
class DeliteAIWorker(context: Context, params: WorkerParameters) : CoroutineWorker(context, params) {
    override suspend fun doWork(): Result {
        return try {
            val client = DeliteAIClient(applicationContext)
            // Perform background AI processing
            Result.success()
        } catch (e: Exception) {
            Result.failure()
        }
    }
}
```

```swift
// iOS Background Processing
import BackgroundTasks

class BackgroundProcessor {
    func scheduleBackgroundRefresh() {
        let request = BGAppRefreshTaskRequest(identifier: "ai.delite.sdk.refresh")
        request.earliestBeginDate = Date(timeIntervalSinceNow: 15 * 60) // 15 minutes
        
        try? BGTaskScheduler.shared.submit(request)
    }
    
    func handleBackgroundRefresh(task: BGAppRefreshTask) {
        task.expirationHandler = {
            task.setTaskCompleted(success: false)
        }
        
        Task {
            do {
                let client = DeliteAIClient()
                // Perform background AI processing
                task.setTaskCompleted(success: true)
            } catch {
                task.setTaskCompleted(success: false)
            }
        }
    }
}
```

## Performance Monitoring

### Memory Profiling
- Use platform-specific profiling tools (Memory Profiler, Instruments)
- Monitor memory usage during AI processing
- Implement memory warnings handling
- Test on low-memory devices

### CPU Optimization
- Profile CPU usage during AI operations
- Optimize algorithms for mobile processors
- Use appropriate threading strategies
- Monitor thermal throttling effects

## Common Mistakes to Avoid

1. **Platform Inconsistencies**: Ensure identical behavior across Android and iOS
2. **Memory Leaks**: Properly manage object lifecycles and references
3. **Thread Safety Issues**: Use appropriate synchronization mechanisms
4. **Poor Error Handling**: Provide meaningful error messages and recovery options
5. **Ignoring Platform Guidelines**: Follow each platform's best practices
6. **Blocking Main Thread**: Keep UI responsive during AI processing
7. **Battery Drain**: Optimize for energy efficiency

Remember: Mobile SDKs are the primary interface for developers. They must be reliable, efficient, and easy to integrate while maintaining the highest performance standards. 